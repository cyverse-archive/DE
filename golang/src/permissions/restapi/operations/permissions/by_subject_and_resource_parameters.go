package permissions

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit"
	"github.com/go-swagger/go-swagger/httpkit/middleware"
	"github.com/go-swagger/go-swagger/httpkit/validate"
	"github.com/go-swagger/go-swagger/swag"

	strfmt "github.com/go-swagger/go-swagger/strfmt"
)

// NewBySubjectAndResourceParams creates a new BySubjectAndResourceParams object
// with the default values initialized.
func NewBySubjectAndResourceParams() BySubjectAndResourceParams {
	var (
		lookupDefault bool = bool(false)
	)
	return BySubjectAndResourceParams{
		Lookup: &lookupDefault,
	}
}

// BySubjectAndResourceParams contains all the bound params for the by subject and resource operation
// typically these are obtained from a http.Request
//
// swagger:parameters bySubjectAndResource
type BySubjectAndResourceParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request

	/*True if a permission lookup should be performed. A permission lookup differs from standard permisison retrieval in two ways. First, only the most permissive permission level available to the subject is returned for any given resource. Second, if the subject happens to be a user then permissions granted to groups that the user belongs to are also included in the results. This parameter is optional and defaults to False.
	  In: query
	  Default: false
	*/
	Lookup *bool
	/*The resource name.
	  Required: true
	  In: path
	*/
	ResourceName string
	/*The resource type name.
	  Required: true
	  In: path
	*/
	ResourceType string
	/*The external subject identifier.
	  Required: true
	  In: path
	*/
	SubjectID string
	/*The subject type name.
	  Required: true
	  In: path
	*/
	SubjectType string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls
func (o *BySubjectAndResourceParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error
	o.HTTPRequest = r

	qs := httpkit.Values(r.URL.Query())

	qLookup, qhkLookup, _ := qs.GetOK("lookup")
	if err := o.bindLookup(qLookup, qhkLookup, route.Formats); err != nil {
		res = append(res, err)
	}

	rResourceName, rhkResourceName, _ := route.Params.GetOK("resource_name")
	if err := o.bindResourceName(rResourceName, rhkResourceName, route.Formats); err != nil {
		res = append(res, err)
	}

	rResourceType, rhkResourceType, _ := route.Params.GetOK("resource_type")
	if err := o.bindResourceType(rResourceType, rhkResourceType, route.Formats); err != nil {
		res = append(res, err)
	}

	rSubjectID, rhkSubjectID, _ := route.Params.GetOK("subject_id")
	if err := o.bindSubjectID(rSubjectID, rhkSubjectID, route.Formats); err != nil {
		res = append(res, err)
	}

	rSubjectType, rhkSubjectType, _ := route.Params.GetOK("subject_type")
	if err := o.bindSubjectType(rSubjectType, rhkSubjectType, route.Formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BySubjectAndResourceParams) bindLookup(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		var lookupDefault bool = bool(false)
		o.Lookup = &lookupDefault
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("lookup", "query", "bool", raw)
	}
	o.Lookup = &value

	return nil
}

func (o *BySubjectAndResourceParams) bindResourceName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	o.ResourceName = raw

	return nil
}

func (o *BySubjectAndResourceParams) bindResourceType(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	o.ResourceType = raw

	return nil
}

func (o *BySubjectAndResourceParams) bindSubjectID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	o.SubjectID = raw

	return nil
}

func (o *BySubjectAndResourceParams) bindSubjectType(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	o.SubjectType = raw

	if err := o.validateSubjectType(formats); err != nil {
		return err
	}

	return nil
}

func (o *BySubjectAndResourceParams) validateSubjectType(formats strfmt.Registry) error {

	if err := validate.Enum("subject_type", "path", o.SubjectType, []interface{}{"user", "group"}); err != nil {
		return err
	}

	return nil
}
